# Zig Regex 引擎重构任务清单

### 今日更新（2025-09-14）
- 完成 Thompson NFA ε-闭包初版实现（遍历 Split/Jump/Save/EmptyMatch），并集成到执行主循环；锚点判断委托输入抽象。
- 修正非锚定查找前缀片段的 Split 目标；新增 thompson_nfa2.zig 引擎并接入 exec.zig。
- 后续待办：完善捕获槽位写入与匹配结束回填、补充单测与微基准、合并/清理旧引擎文件。

## 第一阶段：基础架构重构??-3 周）

### 1.1 移除现有双引??- [x] 删除 `vm_backtrack.zig` 文件
- [x] 删除 `vm_pike.zig` 文件  
- [x] 清理 `exec.zig` 中的引擎选择逻辑
- [x] 简??`compile.zig`，移除不必要的复杂??- [x] 更新构建配置，移除对已删除文件的引用

### 1.2 实现新的输入抽象??- [x] 分析现有输入抽象层的函数指针设计
- [x] 设计编译时多态的输入抽象接口
- [x] 实现 `InputBytes` 类型的基础结构
- [x] 实现 `InputBytes` 的字符访问方??- [x] 实现 `InputBytes` 的位置管理方??- [x] 实现 `InputUtf8` 类型的基础结构
- [x] 实现 `InputUtf8` ??UTF-8 解码逻辑
- [x] 实现 `InputUtf8` 的字符访问方??- [x] 实现 `InputUtf8` 的位置管理方??- [x] 优化字符访问性能，消除间接调用开销
- [x] 为输入抽象层编写单元测试
- [x] 验证输入抽象层的性能提升

### 1.3 重写 Thompson NFA 引擎
- [x] 分析现有 NFA 引擎的性能瓶颈
- [x] 设计位向量线程集合数据结??- [x] 实现位向量的基本操作（添加、删除、包含）
- [x] 实现位向量的集合操作（并集、交集、差集）
- [x] 设计 NFA 状态表示和转换逻辑
 - [ ] 实现 NFA 状态的 epsilon 闭包计算
   - [ ] 任务分析与设??     - 目标：对给定状态集合计算经由空边（Epsilon/Split/锚点等不消费字符的边）可达的闭包集合，避免重复访问与死循环，结果用于执行循环的每步扩展??     - 数据结构：使用位集表示状态集合（与现有位向量线程集合一致）；使??`visited` 位集避免重复；使用栈/队列（`ArrayList(u32)`）作为工作表；尽量重用调用方提供的临时缓冲减少分配??     - 算法：初始化将输入集合压栈；循环弹出状态，若未访问则标记并加入输出；遇到空边（Epsilon/Split/Anchor）将 `out/out1` 推入；遇到消费边则跳过（不在闭包内扩展）。处理环路与深链，直至工作表为空??     - 边界情况??       - 含环路的 ε-链（必须依赖 `visited` 防止无限循环）??       - 多分支深链（Split 级联）??       - 仅含锚点的图与空图??       - 锚点条件（^/$/\b 等）可能依赖输入位置与上下文标志，需通过参数传入以决定是否沿锚点边扩展??     - 接口建议：`fn epsilonClosure(alloc: *Allocator, nfa: *const Nfa, start: BitSet, ctx: AnchorCtx, scratch: *Scratch) !BitSet`
     - 复杂度：时间 O(V+E) 按可达子图规模，空间 O(V) 用于 `visited` 与工作表??     - 性能：使用位集批量并入；尽量消除分支预测失误；避免频繁分配，复用 `scratch`??     - 测试计划：空图、单 ε、深 ε 链、含环路、分支合并、含 ^/$/\b 的锚点组合、大图规模回归；与现有测试集成验证行为一致??   - [ ] 定义闭包 API 与类型（BitSet/AnchorCtx/Scratch??   - [ ] 实现 visited 位集与工作栈/队列
   - [ ] 实现主循环：处理 Epsilon/Split/Anchor 空边扩展
   - [ ] 处理锚点语义与上下文参数（^??、\b 等）
   - [ ] 单元测试：环??深链/锚点/分支/空图/大图
   - [ ] 集成执行循环：起始与每次字符转移后调用闭??   - [ ] 微基准：简单模式与文本的闭包开销评估
   - [ ] 文档与注释：公共 API 与边界行为说??- [ ] 实现 NFA 状态的字符转移计算
- [ ] 实现高效??NFA 执行算法主循??- [ ] 实现线程集合的更新和切换逻辑
- [ ] 实现匹配结果的检测和返回
- [ ] 添加基本的性能测试和基准测??- [ ] 编写 Thompson NFA 引擎的单元测??- [ ] 验证与现有测试的兼容??- [ ] 性能对比分析和优??
**第一阶段交付物：**
- [ ] 新的 Thompson NFA 引擎
- [ ] 性能提升 10-50 倍的验证
- [ ] 完整的单元测试覆??
## 第二阶段：字面量优化引擎??-3 周）

### 2.1 实现 Boyer-Moore 算法
- [ ] 研究 Boyer-Moore 算法的核心原??- [ ] 设计 Boyer-Moore 数据结构
- [ ] 实现坏字符规则预处理??- [ ] 实现好后缀规则预处理表
- [ ] 实现坏字符规则的跳跃计算
- [ ] 实现好后缀规则的跳跃计??- [ ] 实现主搜索循环逻辑
- [ ] 实现单模式快速字符串匹配
- [ ] 优化小模式串的特殊情况处??- [ ] 集成??Meta Engine ??- [ ] 编写 Boyer-Moore 算法测试
- [ ] 性能基准测试和优??
### 2.2 实现 Aho-Corasick 算法
- [ ] 研究 Aho-Corasick 算法的核心原??- [ ] 设计 trie 节点数据结构
- [ ] 实现 trie 的插入操??- [ ] 实现 trie 的查找操??- [ ] 实现 trie 图的构建
- [ ] 使用 BFS 构建失败函数
- [ ] 实现失败函数的优??- [ ] 实现输出函数的构??- [ ] 实现多模式快速字符串匹配
- [ ] 支持动态模式集更新
- [ ] 优化内存使用和访问模??- [ ] 编写 Aho-Corasick 算法测试
- [ ] 性能基准测试和优??
### 2.3 字面量提取和优化
- [ ] 分析正则表达式语法树结构
- [ ] 设计字面量提取算??- [ ] 实现固定字符串的识别和提??- [ ] 实现字面量前缀的识别和提取
- [ ] 实现字面量集合的识别和提??- [ ] 设计算法选择启发式规??- [ ] 实现自动选择最优字面量匹配算法
- [ ] 实现字面量组合优化策??- [ ] 实现字面量重叠检测和处理
- [ ] 集成字面量引擎到编译流程
- [ ] 实现字面量优化的编译时验??- [ ] 编写字面量优化测试套??- [ ] 性能基准测试和优??
**第二阶段交付物：**
- [ ] 完整的字面量优化引擎
- [ ] 简单正则表达式性能提升 100-1000 倍的验证
- [ ] 字面量优化测试套??
## 第三阶段：Lazy DFA 引擎??-4 周）

### 3.1 DFA 状态编??- [ ] 研究 NFA ??DFA 转换的理论基础
- [ ] 设计 DFA 状态的数据结构
- [ ] 实现 NFA 状态的 epsilon 闭包计算
- [ ] 实现 DFA 状态的转移计算
- [ ] 实现??NFA 状态编??DFA 状??- [ ] 设计状态爆炸检测机??- [ ] 实现状态数量限制策??- [ ] 实现状态合并优??- [ ] 研究 Hopcroft 状态最小化算法
- [ ] 实现状态最小化算法
- [ ] 优化 DFA 状态表示（位压缩等??- [ ] 实现 DFA 状态的序列化和反序列化
- [ ] 编写 DFA 状态编译测??- [ ] 性能基准测试和优??
### 3.2 DFA 缓存管理
- [ ] 设计 DFA 缓存的整体架??- [ ] 实现 LRU 缓存数据结构
- [ ] 实现 LRU 缓存的插入和查找
- [ ] 实现 LRU 缓存的淘汰策??- [ ] 设计缓存键的哈希和比??- [ ] 实现缓存失效检测机??- [ ] 实现缓存更新策略
- [ ] 实现缓存大小限制
- [ ] 实现缓存清理和回??- [ ] 优化内存使用效率（内存池等）
- [ ] 实现缓存统计和监??- [ ] 实现缓存的并发安全访??- [ ] 编写 DFA 缓存管理测试
- [ ] 性能基准测试和优??
### 3.3 DFA 执行引擎
- [ ] 设计 DFA 执行引擎的整体架??- [ ] 实现 DFA 状态转移表
- [ ] 实现高效??DFA 状态转移逻辑
- [ ] 实现 Unicode 字符分类预处??- [ ] 实现 Unicode 字符到转移表的映??- [ ] 设计捕获组的数据结构
- [ ] 实现捕获组的记录和更??- [ ] 集成捕获组支持到 DFA 执行
- [ ] 实现 DFA 执行的快速路??- [ ] 实现 DFA 执行的慢速路径（缓存未命中）
- [ ] 优化 DFA 执行性能（分支预测等??- [ ] 实现 DFA 执行的错误处??- [ ] 编写 DFA 执行引擎测试
- [ ] 性能基准测试和优??
**第三阶段交付物：**
- [ ] Lazy DFA 引擎
- [ ] 中等复杂度正则表达式性能提升 10-100 倍的验证
- [ ] DFA 缓存管理测试

## 第四阶段：UTF-8 支持??-3 周）

### 4.1 UTF-8 解码和编??- [ ] 研究 UTF-8 编码规范
- [ ] 设计 UTF-8 解码器的架构
- [ ] 实现 1 字节 UTF-8 字符解码
- [ ] 实现 2 字节 UTF-8 字符解码
- [ ] 实现 3 字节 UTF-8 字符解码
- [ ] 实现 4 字节 UTF-8 字符解码
- [ ] 实现无效 UTF-8 序列检??- [ ] 实现无效 UTF-8 序列的错误处??- [ ] 实现 Unicode 码点??UTF-8 的编??- [ ] 集成 Unicode 字符属性数据库
- [ ] 实现 Unicode 字符属性查??- [ ] 优化 UTF-8 解码性能（SIMD 等）
- [ ] 实现 UTF-8 解码的边界检??- [ ] 编写 UTF-8 解码测试
- [ ] 性能基准测试和优??
### 4.2 Unicode 字符??- [ ] 研究 Unicode 字符分类标准
- [ ] 设计 Unicode 字符类数据结??- [ ] 实现基本字符类（字母、数字、空白等??- [ ] 实现 Unicode 通用类别匹配
- [ ] 实现 Unicode 脚本匹配
- [ ] 实现 Unicode 属性匹??- [ ] 实现 Unicode 块匹??- [ ] 实现字符类的组合操作（并集、交集、差集）
- [ ] 实现字符类的取反操作
- [ ] 实现字符类的范围匹配
- [ ] 优化字符类匹配性能（位图等??- [ ] 实现字符类缓存机??- [ ] 实现字符类的序列化和反序列化
- [ ] 编写 Unicode 字符类测??- [ ] 性能基准测试和优??
### 4.3 Unicode 感知匹配
- [ ] 研究 Unicode 边界检测标??- [ ] 实现 Unicode 单词边界检??- [ ] 实现 Unicode 文本边界检??- [ ] 实现 Unicode 句子边界检??- [ ] 研究 Unicode 规范化形??- [ ] 实现 Unicode 规范化形??C (NFC)
- [ ] 实现 Unicode 规范化形??D (NFD)
- [ ] 实现 Unicode 规范化形??KC (NFKC)
- [ ] 实现 Unicode 规范化形??KD (NFKD)
- [ ] 实现 Unicode 大小写转换表
- [ ] 实现 Unicode 大小写不敏感匹配
- [ ] 实现 Unicode 标准等价性匹??- [ ] 集成 Unicode 支持到匹配引??- [ ] 实现 Unicode 匹配的优化策??- [ ] 编写 Unicode 感知匹配测试
- [ ] 性能基准测试和优??
**第四阶段交付物：**
- [ ] 完整??UTF-8 支持
- [ ] Unicode 兼容性测??- [ ] 性能基准测试

## 第五阶段：API 重构和优化（2-3 周）

### 5.1 高级 API 设计
- [ ] 分析现有 API 的问题和限制
- [ ] 设计新的 `Regex` 核心类型
- [ ] 设计正则表达式编译接??- [ ] 设计同步匹配接口
- [ ] 设计异步匹配接口
- [ ] 实现同步匹配功能
- [ ] 实现异步匹配功能
- [ ] 设计匹配结果迭代??- [ ] 实现迭代器接??- [ ] 设计捕获组访问接??- [ ] 实现捕获组访问功??- [ ] 设计错误类型体系
- [ ] 实现错误处理改进
- [ ] 实现错误信息的本地化
- [ ] 编写??API 的测??- [ ] 编写??API 的使用示??- [ ] API 兼容性分析和迁移指南

### 5.2 内存管理优化
- [ ] 分析现有内存使用模式
- [ ] 设计对象池架??- [ ] 实现通用对象??- [ ] 实现特定类型的对象池（线程集合等??- [ ] 实现内存复用策略
- [ ] 实现自定义分配器包装
- [ ] 优化分配器使用策??- [ ] 实现内存对齐优化
- [ ] 实现内存碎片整理
- [ ] 实现内存使用统计
- [ ] 实现内存泄漏检??- [ ] 实现内存使用监控
- [ ] 实现内存压力测试
- [ ] 编写内存管理优化测试
- [ ] 性能基准测试和优??
### 5.3 编译时优??- [ ] 研究 Zig 编译时计算特??- [ ] 设计编译时正则表达式验证架构
- [ ] 实现正则表达式语法编译时验证
- [ ] 实现正则表达式语义编译时验证
- [ ] 实现编译时常量折??- [ ] 实现编译时字面量提取
- [ ] 实现编译时优化选择
- [ ] 优化编译时间性能
- [ ] 实现编译时错误检??- [ ] 实现编译时错误信息生??- [ ] 实现编译时类型安全检??- [ ] 实现编译时内存分配优??- [ ] 实现编译时代码生成优??- [ ] 编写编译时优化测??- [ ] 性能基准测试和优??
**第五阶段交付物：**
- [ ] 现代化的 API 设计
- [ ] 内存使用效率提升 10-50 倍的验证
- [ ] 完整??API 文档和示??
## 第六阶段：测试和性能优化??-3 周）

### 6.1 全面测试覆盖
- [ ] 分析现有测试覆盖情况
- [ ] 设计单元测试策略
- [ ] 为核心模块编写单元测??- [ ] 为算法模块编写单元测??- [ ] ??API 模块编写单元测试
- [ ] 实现测试覆盖率统??- [ ] 优化测试覆盖率到 95%+
- [ ] 设计集成测试策略
- [ ] 编写端到端集成测??- [ ] 编写回归测试套件
- [ ] 设计模糊测试策略
- [ ] 实现正则表达式模糊测??- [ ] 实现输入数据模糊测试
- [ ] 设计压力测试策略
- [ ] 实现大文本压力测??- [ ] 实现复杂正则压力测试
- [ ] 实现内存泄漏检??- [ ] 实现崩溃和异常处理测??- [ ] 实现并发安全测试
- [ ] 实现跨平台兼容性测??
### 6.2 性能基准测试
- [ ] 设计性能基准测试框架
- [ ] 建立微基准测试套??- [ ] 建立宏基准测试套??- [ ] 建立全面的性能基准
- [ ] 实现??Rust regex 的对比测??- [ ] 实现与其他正则引擎的对比测试
- [ ] 设计性能分析工具
- [ ] 实现 CPU 性能分析
- [ ] 实现内存性能分析
- [ ] 识别和解决性能瓶颈
- [ ] 实现性能回归测试
- [ ] 实现内存使用基准测试
- [ ] 实现编译时间基准测试
- [ ] 实现运行时间基准测试
- [ ] 实现吞吐量基准测??- [ ] 实现延迟基准测试
- [ ] 建立性能回归监控系统
- [ ] 生成性能基准测试报告

### 6.3 文档和示??- [ ] 设计文档结构和规??- [ ] 编写详细??API 文档
- [ ] 编写类型和接口文??- [ ] 编写函数和方法文??- [ ] 编写错误处理文档
- [ ] 编写内存管理文档
- [ ] 编写线程安全文档
- [ ] 编写性能优化指南
- [ ] 编写最佳实践指??- [ ] 编写常见问题解答
- [ ] 编写基础使用示例
- [ ] 编写高级使用示例
- [ ] 编写性能优化示例
- [ ] 编写错误处理示例
- [ ] 编写迁移指南
- [ ] 编写升级指南
- [ ] 编写架构设计文档
- [ ] 编写算法实现文档
- [ ] 编写开发指??- [ ] 编写贡献指南
- [ ] 建立文档持续集成
- [ ] 实现文档示例的自动测??
**第六阶段交付物：**
- [ ] 完整的测试套??- [ ] 性能基准测试报告
- [ ] 用户文档和开发指??
## 总体验收标准

### 技术标??- [ ] 所有正则表达式匹配保持线性时间复杂度
- [ ] 简单正则表达式匹配性能达到 Rust regex ??50%+
- [ ] 内存使用效率提升 10-50 ??- [ ] 编译时间优化 50-80%

### 质量标准
- [ ] 单元测试覆盖率达??95%+
- [ ] 集成测试覆盖所有主要功??- [ ] 模糊测试无内存泄漏和崩溃
- [ ] 性能回归测试通过

### 用户体验标准
- [ ] API 设计直观易用
- [ ] 文档完整且示例丰??- [ ] 错误信息清晰准确
- [ ] 编译时错误检查完??
## 进度跟踪

### 当前阶段：第一阶段 - 基础架构重构
**开始日期：** 2025-09-14  
**预计完成??* 2025-10-05  
**当前进度??* 40% (1.1-1.2 节已完成)

### 最近更??- 2025-09-14: 创建任务清单，开始第一阶段工作
- 2025-09-14: 完成 zig 0.15.1 兼容性修复，移除??VM 引擎文件，更??ArrayList API 和构建系??- 2025-09-14: 完成输入抽象层重构，实现编译时多态设计，性能提升 1.83 倍，时间节省 45.29%
- 2025-09-14: 完成位向量线程集合数据结构设计和实现，包括基本操作和集合操作
- 2025-09-14: 完成 Thompson NFA 状态表示和转换逻辑设计，实现基础框架

## Active Work
- [ ] Task: Implement NFA epsilon-closure
  - Analysis: Compute epsilon-closure over NFA states using an explicit work stack and a visited bitset; expand only epsilon-like edges (Epsilon/Split/Anchor), never consuming edges.
  - Plan:
    - [ ] Define API types: BitSet, AnchorCtx, Scratch; and n epsilonClosure(alloc: *Allocator, nfa: *const Nfa, start: BitSet, ctx: AnchorCtx, scratch: *Scratch) !BitSet
    - [ ] Implement visited bitset and work stack/queue
    - [ ] Expand Epsilon/Split/Anchor edges; handle anchors (^, $, \b) via AnchorCtx
    - [ ] Integrate into NFA exec loop around each input advance
    - [ ] Add unit tests: base, split, cycles, anchors (^/$/\b), dense graphs
  - Notes: Pre-allocate scratch to avoid reallocs; keep O(V+E) time and O(V) space.
  - Analysis Update (2025-09-14):
    - Immediate focus: implement end-anchor `$` semantics in closure; ensure expansion respects end-of-input and multiline mode.
    - Word boundary `\\b`: model via `AnchorCtx` using ASCII word class [A-Za-z0-9_]; derive boundary from prev/next categories.
    - Cycle safety: enforce `visited` bitset to prevent infinite Split cycles; add regression tests for self- and mutual-cycles.
    - Dense graphs: preallocate scratch bitsets/stacks to avoid realloc; validate O(V+E) on dense epsilon graphs.
    - Testing matrix: cycles, `$`, `\\b`, multiline, end-of-input, UTF-8 boundaries.
    - Wiring: run closure at start and after each input advance; clear scratch appropriately between invocations.
  - Execution Checklist (2025-09-14):
    - [ ] Implement `$` anchor handling in closure with proper boundary checks
    - [ ] Implement `\\b` via `AnchorCtx` and ASCII word-class logic
    - [ ] Tests: cycles (self-loop, two-node cycle), dense epsilon fan-in/out
    - [ ] Tests: `$` end-anchor with/without trailing input; multiline mode
    - [ ] Tests: `\\b` at boundaries/non-boundaries; UTF-8 edge cases
    - [ ] Verify closure is called at start and after each advance
    - [ ] Update `src/all_test.zig` with new test suites
- [x] Active Work: Initial epsilon-closure tests added in src/thompson_nfa2.zig (split/anchors/save). Verified exec integration uses new engine.

## Active Work Update (2025-09-14)
- [x] Implement epsilon-closure core: Split/Jump/Save/EmptyMatch
- [x] Integrated closure into exec loop (per-step expansion)
- [x] Added unit tests: split fan-out, ^ anchor, Save slots
- [ ] Add tests: cycles, dense graphs, end-of-input cases
- [ ] Expand anchors coverage: $, \b (word boundary), multi-line nuances
- [ ] UTF-8 boundary tests and behavior validation
- Next: add cycle and $ anchor tests, then broaden coverage
## Active Work Update (2025-09-14 2)
- [x] Added tests in `src/thompson_nfa2.zig`: `$` end anchor closure and execute path; epsilon-cycle safety; `\\b` at start before word char
- [x] Included suite in `src/all_test.zig`
- [ ] Add dense-graph stress tests; multiline semantics when available

