# Zig Regex 引擎重构任务清单

### 今日更新（2025-09-14）
- 完成 Thompson NFA ε-闭包初版实现（遍历 Split/Jump/Save/EmptyMatch），并集成到执行主循环；锚点判断委托输入抽象。
- 修正非锚定查找前缀片段的 Split 目标；新增 thompson_nfa2.zig 引擎并接入 exec.zig。
- 后续待办：完善捕获槽位写入与匹配结束回填、补充单测与微基准、合并/清理旧引擎文件。

## 第一阶段：基础架构重构�?-3 周）

### 1.1 移除现有双引�?- [x] 删除 `vm_backtrack.zig` 文件
- [x] 删除 `vm_pike.zig` 文件  
- [x] 清理 `exec.zig` 中的引擎选择逻辑
- [x] 简�?`compile.zig`，移除不必要的复杂�?- [x] 更新构建配置，移除对已删除文件的引用

### 1.2 实现新的输入抽象�?- [x] 分析现有输入抽象层的函数指针设计
- [x] 设计编译时多态的输入抽象接口
- [x] 实现 `InputBytes` 类型的基础结构
- [x] 实现 `InputBytes` 的字符访问方�?- [x] 实现 `InputBytes` 的位置管理方�?- [x] 实现 `InputUtf8` 类型的基础结构
- [x] 实现 `InputUtf8` �?UTF-8 解码逻辑
- [x] 实现 `InputUtf8` 的字符访问方�?- [x] 实现 `InputUtf8` 的位置管理方�?- [x] 优化字符访问性能，消除间接调用开销
- [x] 为输入抽象层编写单元测试
- [x] 验证输入抽象层的性能提升

### 1.3 重写 Thompson NFA 引擎
- [x] 分析现有 NFA 引擎的性能瓶颈
- [x] 设计位向量线程集合数据结�?- [x] 实现位向量的基本操作（添加、删除、包含）
- [x] 实现位向量的集合操作（并集、交集、差集）
- [x] 设计 NFA 状态表示和转换逻辑
 - [ ] 实现 NFA 状态的 epsilon 闭包计算
   - [ ] 任务分析与设�?     - 目标：对给定状态集合计算经由空边（Epsilon/Split/锚点等不消费字符的边）可达的闭包集合，避免重复访问与死循环，结果用于执行循环的每步扩展�?     - 数据结构：使用位集表示状态集合（与现有位向量线程集合一致）；使�?`visited` 位集避免重复；使用栈/队列（`ArrayList(u32)`）作为工作表；尽量重用调用方提供的临时缓冲减少分配�?     - 算法：初始化将输入集合压栈；循环弹出状态，若未访问则标记并加入输出；遇到空边（Epsilon/Split/Anchor）将 `out/out1` 推入；遇到消费边则跳过（不在闭包内扩展）。处理环路与深链，直至工作表为空�?     - 边界情况�?       - 含环路的 ε-链（必须依赖 `visited` 防止无限循环）�?       - 多分支深链（Split 级联）�?       - 仅含锚点的图与空图�?       - 锚点条件（^/$/\b 等）可能依赖输入位置与上下文标志，需通过参数传入以决定是否沿锚点边扩展�?     - 接口建议：`fn epsilonClosure(alloc: *Allocator, nfa: *const Nfa, start: BitSet, ctx: AnchorCtx, scratch: *Scratch) !BitSet`
     - 复杂度：时间 O(V+E) 按可达子图规模，空间 O(V) 用于 `visited` 与工作表�?     - 性能：使用位集批量并入；尽量消除分支预测失误；避免频繁分配，复用 `scratch`�?     - 测试计划：空图、单 ε、深 ε 链、含环路、分支合并、含 ^/$/\b 的锚点组合、大图规模回归；与现有测试集成验证行为一致�?   - [ ] 定义闭包 API 与类型（BitSet/AnchorCtx/Scratch�?   - [ ] 实现 visited 位集与工作栈/队列
   - [ ] 实现主循环：处理 Epsilon/Split/Anchor 空边扩展
   - [ ] 处理锚点语义与上下文参数（^�?、\b 等）
   - [ ] 单元测试：环�?深链/锚点/分支/空图/大图
   - [ ] 集成执行循环：起始与每次字符转移后调用闭�?   - [ ] 微基准：简单模式与文本的闭包开销评估
   - [ ] 文档与注释：公共 API 与边界行为说�?- [ ] 实现 NFA 状态的字符转移计算
- [ ] 实现高效�?NFA 执行算法主循�?- [ ] 实现线程集合的更新和切换逻辑
- [ ] 实现匹配结果的检测和返回
- [ ] 添加基本的性能测试和基准测�?- [ ] 编写 Thompson NFA 引擎的单元测�?- [ ] 验证与现有测试的兼容�?- [ ] 性能对比分析和优�?
**第一阶段交付物：**
- [ ] 新的 Thompson NFA 引擎
- [ ] 性能提升 10-50 倍的验证
- [ ] 完整的单元测试覆�?
## 第二阶段：字面量优化引擎�?-3 周）

### 2.1 实现 Boyer-Moore 算法
- [ ] 研究 Boyer-Moore 算法的核心原�?- [ ] 设计 Boyer-Moore 数据结构
- [ ] 实现坏字符规则预处理�?- [ ] 实现好后缀规则预处理表
- [ ] 实现坏字符规则的跳跃计算
- [ ] 实现好后缀规则的跳跃计�?- [ ] 实现主搜索循环逻辑
- [ ] 实现单模式快速字符串匹配
- [ ] 优化小模式串的特殊情况处�?- [ ] 集成�?Meta Engine �?- [ ] 编写 Boyer-Moore 算法测试
- [ ] 性能基准测试和优�?
### 2.2 实现 Aho-Corasick 算法
- [ ] 研究 Aho-Corasick 算法的核心原�?- [ ] 设计 trie 节点数据结构
- [ ] 实现 trie 的插入操�?- [ ] 实现 trie 的查找操�?- [ ] 实现 trie 图的构建
- [ ] 使用 BFS 构建失败函数
- [ ] 实现失败函数的优�?- [ ] 实现输出函数的构�?- [ ] 实现多模式快速字符串匹配
- [ ] 支持动态模式集更新
- [ ] 优化内存使用和访问模�?- [ ] 编写 Aho-Corasick 算法测试
- [ ] 性能基准测试和优�?
### 2.3 字面量提取和优化
- [ ] 分析正则表达式语法树结构
- [ ] 设计字面量提取算�?- [ ] 实现固定字符串的识别和提�?- [ ] 实现字面量前缀的识别和提取
- [ ] 实现字面量集合的识别和提�?- [ ] 设计算法选择启发式规�?- [ ] 实现自动选择最优字面量匹配算法
- [ ] 实现字面量组合优化策�?- [ ] 实现字面量重叠检测和处理
- [ ] 集成字面量引擎到编译流程
- [ ] 实现字面量优化的编译时验�?- [ ] 编写字面量优化测试套�?- [ ] 性能基准测试和优�?
**第二阶段交付物：**
- [ ] 完整的字面量优化引擎
- [ ] 简单正则表达式性能提升 100-1000 倍的验证
- [ ] 字面量优化测试套�?
## 第三阶段：Lazy DFA 引擎�?-4 周）

### 3.1 DFA 状态编�?- [ ] 研究 NFA �?DFA 转换的理论基础
- [ ] 设计 DFA 状态的数据结构
- [ ] 实现 NFA 状态的 epsilon 闭包计算
- [ ] 实现 DFA 状态的转移计算
- [ ] 实现�?NFA 状态编�?DFA 状�?- [ ] 设计状态爆炸检测机�?- [ ] 实现状态数量限制策�?- [ ] 实现状态合并优�?- [ ] 研究 Hopcroft 状态最小化算法
- [ ] 实现状态最小化算法
- [ ] 优化 DFA 状态表示（位压缩等�?- [ ] 实现 DFA 状态的序列化和反序列化
- [ ] 编写 DFA 状态编译测�?- [ ] 性能基准测试和优�?
### 3.2 DFA 缓存管理
- [ ] 设计 DFA 缓存的整体架�?- [ ] 实现 LRU 缓存数据结构
- [ ] 实现 LRU 缓存的插入和查找
- [ ] 实现 LRU 缓存的淘汰策�?- [ ] 设计缓存键的哈希和比�?- [ ] 实现缓存失效检测机�?- [ ] 实现缓存更新策略
- [ ] 实现缓存大小限制
- [ ] 实现缓存清理和回�?- [ ] 优化内存使用效率（内存池等）
- [ ] 实现缓存统计和监�?- [ ] 实现缓存的并发安全访�?- [ ] 编写 DFA 缓存管理测试
- [ ] 性能基准测试和优�?
### 3.3 DFA 执行引擎
- [ ] 设计 DFA 执行引擎的整体架�?- [ ] 实现 DFA 状态转移表
- [ ] 实现高效�?DFA 状态转移逻辑
- [ ] 实现 Unicode 字符分类预处�?- [ ] 实现 Unicode 字符到转移表的映�?- [ ] 设计捕获组的数据结构
- [ ] 实现捕获组的记录和更�?- [ ] 集成捕获组支持到 DFA 执行
- [ ] 实现 DFA 执行的快速路�?- [ ] 实现 DFA 执行的慢速路径（缓存未命中）
- [ ] 优化 DFA 执行性能（分支预测等�?- [ ] 实现 DFA 执行的错误处�?- [ ] 编写 DFA 执行引擎测试
- [ ] 性能基准测试和优�?
**第三阶段交付物：**
- [ ] Lazy DFA 引擎
- [ ] 中等复杂度正则表达式性能提升 10-100 倍的验证
- [ ] DFA 缓存管理测试

## 第四阶段：UTF-8 支持�?-3 周）

### 4.1 UTF-8 解码和编�?- [ ] 研究 UTF-8 编码规范
- [ ] 设计 UTF-8 解码器的架构
- [ ] 实现 1 字节 UTF-8 字符解码
- [ ] 实现 2 字节 UTF-8 字符解码
- [ ] 实现 3 字节 UTF-8 字符解码
- [ ] 实现 4 字节 UTF-8 字符解码
- [ ] 实现无效 UTF-8 序列检�?- [ ] 实现无效 UTF-8 序列的错误处�?- [ ] 实现 Unicode 码点�?UTF-8 的编�?- [ ] 集成 Unicode 字符属性数据库
- [ ] 实现 Unicode 字符属性查�?- [ ] 优化 UTF-8 解码性能（SIMD 等）
- [ ] 实现 UTF-8 解码的边界检�?- [ ] 编写 UTF-8 解码测试
- [ ] 性能基准测试和优�?
### 4.2 Unicode 字符�?- [ ] 研究 Unicode 字符分类标准
- [ ] 设计 Unicode 字符类数据结�?- [ ] 实现基本字符类（字母、数字、空白等�?- [ ] 实现 Unicode 通用类别匹配
- [ ] 实现 Unicode 脚本匹配
- [ ] 实现 Unicode 属性匹�?- [ ] 实现 Unicode 块匹�?- [ ] 实现字符类的组合操作（并集、交集、差集）
- [ ] 实现字符类的取反操作
- [ ] 实现字符类的范围匹配
- [ ] 优化字符类匹配性能（位图等�?- [ ] 实现字符类缓存机�?- [ ] 实现字符类的序列化和反序列化
- [ ] 编写 Unicode 字符类测�?- [ ] 性能基准测试和优�?
### 4.3 Unicode 感知匹配
- [ ] 研究 Unicode 边界检测标�?- [ ] 实现 Unicode 单词边界检�?- [ ] 实现 Unicode 文本边界检�?- [ ] 实现 Unicode 句子边界检�?- [ ] 研究 Unicode 规范化形�?- [ ] 实现 Unicode 规范化形�?C (NFC)
- [ ] 实现 Unicode 规范化形�?D (NFD)
- [ ] 实现 Unicode 规范化形�?KC (NFKC)
- [ ] 实现 Unicode 规范化形�?KD (NFKD)
- [ ] 实现 Unicode 大小写转换表
- [ ] 实现 Unicode 大小写不敏感匹配
- [ ] 实现 Unicode 标准等价性匹�?- [ ] 集成 Unicode 支持到匹配引�?- [ ] 实现 Unicode 匹配的优化策�?- [ ] 编写 Unicode 感知匹配测试
- [ ] 性能基准测试和优�?
**第四阶段交付物：**
- [ ] 完整�?UTF-8 支持
- [ ] Unicode 兼容性测�?- [ ] 性能基准测试

## 第五阶段：API 重构和优化（2-3 周）

### 5.1 高级 API 设计
- [ ] 分析现有 API 的问题和限制
- [ ] 设计新的 `Regex` 核心类型
- [ ] 设计正则表达式编译接�?- [ ] 设计同步匹配接口
- [ ] 设计异步匹配接口
- [ ] 实现同步匹配功能
- [ ] 实现异步匹配功能
- [ ] 设计匹配结果迭代�?- [ ] 实现迭代器接�?- [ ] 设计捕获组访问接�?- [ ] 实现捕获组访问功�?- [ ] 设计错误类型体系
- [ ] 实现错误处理改进
- [ ] 实现错误信息的本地化
- [ ] 编写�?API 的测�?- [ ] 编写�?API 的使用示�?- [ ] API 兼容性分析和迁移指南

### 5.2 内存管理优化
- [ ] 分析现有内存使用模式
- [ ] 设计对象池架�?- [ ] 实现通用对象�?- [ ] 实现特定类型的对象池（线程集合等�?- [ ] 实现内存复用策略
- [ ] 实现自定义分配器包装
- [ ] 优化分配器使用策�?- [ ] 实现内存对齐优化
- [ ] 实现内存碎片整理
- [ ] 实现内存使用统计
- [ ] 实现内存泄漏检�?- [ ] 实现内存使用监控
- [ ] 实现内存压力测试
- [ ] 编写内存管理优化测试
- [ ] 性能基准测试和优�?
### 5.3 编译时优�?- [ ] 研究 Zig 编译时计算特�?- [ ] 设计编译时正则表达式验证架构
- [ ] 实现正则表达式语法编译时验证
- [ ] 实现正则表达式语义编译时验证
- [ ] 实现编译时常量折�?- [ ] 实现编译时字面量提取
- [ ] 实现编译时优化选择
- [ ] 优化编译时间性能
- [ ] 实现编译时错误检�?- [ ] 实现编译时错误信息生�?- [ ] 实现编译时类型安全检�?- [ ] 实现编译时内存分配优�?- [ ] 实现编译时代码生成优�?- [ ] 编写编译时优化测�?- [ ] 性能基准测试和优�?
**第五阶段交付物：**
- [ ] 现代化的 API 设计
- [ ] 内存使用效率提升 10-50 倍的验证
- [ ] 完整�?API 文档和示�?
## 第六阶段：测试和性能优化�?-3 周）

### 6.1 全面测试覆盖
- [ ] 分析现有测试覆盖情况
- [ ] 设计单元测试策略
- [ ] 为核心模块编写单元测�?- [ ] 为算法模块编写单元测�?- [ ] �?API 模块编写单元测试
- [ ] 实现测试覆盖率统�?- [ ] 优化测试覆盖率到 95%+
- [ ] 设计集成测试策略
- [ ] 编写端到端集成测�?- [ ] 编写回归测试套件
- [ ] 设计模糊测试策略
- [ ] 实现正则表达式模糊测�?- [ ] 实现输入数据模糊测试
- [ ] 设计压力测试策略
- [ ] 实现大文本压力测�?- [ ] 实现复杂正则压力测试
- [ ] 实现内存泄漏检�?- [ ] 实现崩溃和异常处理测�?- [ ] 实现并发安全测试
- [ ] 实现跨平台兼容性测�?
### 6.2 性能基准测试
- [ ] 设计性能基准测试框架
- [ ] 建立微基准测试套�?- [ ] 建立宏基准测试套�?- [ ] 建立全面的性能基准
- [ ] 实现�?Rust regex 的对比测�?- [ ] 实现与其他正则引擎的对比测试
- [ ] 设计性能分析工具
- [ ] 实现 CPU 性能分析
- [ ] 实现内存性能分析
- [ ] 识别和解决性能瓶颈
- [ ] 实现性能回归测试
- [ ] 实现内存使用基准测试
- [ ] 实现编译时间基准测试
- [ ] 实现运行时间基准测试
- [ ] 实现吞吐量基准测�?- [ ] 实现延迟基准测试
- [ ] 建立性能回归监控系统
- [ ] 生成性能基准测试报告

### 6.3 文档和示�?- [ ] 设计文档结构和规�?- [ ] 编写详细�?API 文档
- [ ] 编写类型和接口文�?- [ ] 编写函数和方法文�?- [ ] 编写错误处理文档
- [ ] 编写内存管理文档
- [ ] 编写线程安全文档
- [ ] 编写性能优化指南
- [ ] 编写最佳实践指�?- [ ] 编写常见问题解答
- [ ] 编写基础使用示例
- [ ] 编写高级使用示例
- [ ] 编写性能优化示例
- [ ] 编写错误处理示例
- [ ] 编写迁移指南
- [ ] 编写升级指南
- [ ] 编写架构设计文档
- [ ] 编写算法实现文档
- [ ] 编写开发指�?- [ ] 编写贡献指南
- [ ] 建立文档持续集成
- [ ] 实现文档示例的自动测�?
**第六阶段交付物：**
- [ ] 完整的测试套�?- [ ] 性能基准测试报告
- [ ] 用户文档和开发指�?
## 总体验收标准

### 技术标�?- [ ] 所有正则表达式匹配保持线性时间复杂度
- [ ] 简单正则表达式匹配性能达到 Rust regex �?50%+
- [ ] 内存使用效率提升 10-50 �?- [ ] 编译时间优化 50-80%

### 质量标准
- [ ] 单元测试覆盖率达�?95%+
- [ ] 集成测试覆盖所有主要功�?- [ ] 模糊测试无内存泄漏和崩溃
- [ ] 性能回归测试通过

### 用户体验标准
- [ ] API 设计直观易用
- [ ] 文档完整且示例丰�?- [ ] 错误信息清晰准确
- [ ] 编译时错误检查完�?
## 进度跟踪

### 当前阶段：第一阶段 - 基础架构重构
**开始日期：** 2025-09-14  
**预计完成�?* 2025-10-05  
**当前进度�?* 40% (1.1-1.2 节已完成)

### 最近更�?- 2025-09-14: 创建任务清单，开始第一阶段工作
- 2025-09-14: 完成 zig 0.15.1 兼容性修复，移除�?VM 引擎文件，更�?ArrayList API 和构建系�?- 2025-09-14: 完成输入抽象层重构，实现编译时多态设计，性能提升 1.83 倍，时间节省 45.29%
- 2025-09-14: 完成位向量线程集合数据结构设计和实现，包括基本操作和集合操作
- 2025-09-14: 完成 Thompson NFA 状态表示和转换逻辑设计，实现基础框架
